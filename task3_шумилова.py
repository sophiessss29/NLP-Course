# -*- coding: utf-8 -*-
"""task3_Шумилова.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FtRxNPmWRo61o7CuzeFGx1couBvg-CaT
"""

!pip install aiogram -q

#библиотеки для бота
from aiogram import Bot, Dispatcher, types
import logging
import asyncio
import sys
from aiogram.filters import Command
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

#база бота
logging.basicConfig(level=logging.INFO)

dp = Dispatcher()
bot = Bot(token='')

#обработка файла с датасетом
import json

with open('faq.json', 'r') as file:
    data = json.load(file)

print(data)

#собираем отдельно списко вопросов и список ответов
faq_questions = [pare['question'] for pares in data.values() for pare in pares]
faq_answers = [pare['answer'] for pares in data.values() for pare in pares]

#библиотеки для реализации метода TF-IDF
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

#TF-IDF преобразование
vectorizer = TfidfVectorizer()
tfidf_matrix = vectorizer.fit_transform(faq_questions)

#функция для использования TF-IDF метода
def tf_idf(query):

    #преобразуем запрос в вектор
    query_vec = vectorizer.transform([query])
    #вычисляем косинусное сходство
    similarities = cosine_similarity(query_vec, tfidf_matrix)
    #ищем индекс наиболее близкого вопроса на основе косинусного сходства
    best_match_idx = similarities.argmax()
    #берем лучший ответ
    best_answer = faq_answers[best_match_idx]

    return best_answer

#библиотеки для реализации метода Word2Vec
import gensim
import numpy as np
from gensim.models import Word2Vec
from sklearn.metrics.pairwise import cosine_similarity

#подгружаем Word2Vec
sentences = [q.split() for q in faq_questions]
model = Word2Vec(sentences, vector_size=100, window=5, min_count=1, workers=4)

#Функция для усреднения векторов слов в вопросе
def sentence_vector(sentence, model):

    words = sentence.split()
    vectors = [model.wv[word] for word in words if word in model.wv]

    return np.mean(vectors, axis=0)



#векторизуем вопросы из датасета
faq_vectors = np.array([sentence_vector(q, model) for q in faq_questions])


#функция для использования word2vec метода
def word_2_vec(query):

    #векторизируем вопрос
    query_vector = sentence_vector(query, model).reshape(1, -1)
    #оценка косинусного сходства
    similarities = cosine_similarity(query_vector, faq_vectors)
    best_match_idx = similarities.argmax()
    best_answer = faq_answers[best_match_idx]

    return best_answer

#список кнопок
kb = [
    [
        KeyboardButton(text="О компании"),
        KeyboardButton(text="Пожаловаться")
    ]
]

#интерфейс с кнопками
keyboard = ReplyKeyboardMarkup(
    keyboard=kb,
    resize_keyboard=True,
    input_field_placeholder="Выберите действие"
    )

#обрабатываем команду "/start"
@dp.message(Command("start"))
async def start_command(message: types.Message):
    await message.answer("Здравствуйте! Я виртуальный помощник, помогу Вам, пока люди заняты. Что у Вас случилось?", reply_markup=keyboard)

#обрабатываем кнопку "О компании"
@dp.message(lambda message: message.text == "О компании")
async def about_bot(message: types.Message):
    await message.answer("Наша компания занимается доставкой товаров по всей стране.")

#обрабатываем кнопку "Пожаловаться"
@dp.message(lambda message: message.text == "Пожаловаться")
async def about_bot(message: types.Message):
    await message.answer("Пожалуйста, пришлите фотографию, иллюстрирующую Вашу проблему")

#обрабатываем изображение
@dp.message(lambda message: message.photo)
async def get_photo(message: types.Message):
    photo = await bot.get_file(message.photo[-1].file_id)
    photo_name = photo.file_path.split("/")[-1]
    photo_size = message.photo[-1].file_size
    await message.answer(f'Файл: {photo_name}\n\nРазмер: {photo_size} байт.\n\nВаш запрос находится в обработке. Пожалуйста, ожидайте ответа. Благодарим за обращение!')

#обработка вопросов пользователей
@dp.message()
async def answers(message: types.Message):
    quiry = message.text
    tf_idf_answer = tf_idf(quiry)
    word_2_vec_answer = word_2_vec(quiry)
    await message.answer(f"Ваш запрос: {quiry}\n\nОтвет, полученный при помощи метода TF-IDF: {tf_idf_answer}\n\nОтвет, полученный при помощи метода Word2Vec: {word_2_vec_answer}")

async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    await main()
